//#if V4 || V3 || V2 || V1 || V0
package hudson;
//#if V0
import com.sun.jna.Memory;
import com.sun.jna.Native;
import com.sun.jna.NativeLong;
import hudson.Proc.LocalProc;
//#endif
import hudson.model.TaskListener;
//#if V0
import hudson.os.PosixAPI;
//#endif
//#if V1 || V2
import jenkins.model.Jenkins;
//#endif
//#if V3 || V4
import hudson.model.Hudson;
//#endif
//#if V1 || V2 || V3
import static hudson.util.jna.GNUCLibrary.LIBC;
//#endif
import hudson.util.IOException2;
import hudson.util.QuotedStringTokenizer;
import hudson.util.VariableResolver;
//#if V0
import jenkins.model.Jenkins;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.time.FastDateFormat;
//#endif
//#if V1 || V2 || V3 || V4
import hudson.Proc.LocalProc;
//#endif
//#if V1 || V2 || V3
import hudson.os.PosixAPI;
//#endif
//#if V4
import org.eclipse.hudson.jna.NativeAccessException;
import org.eclipse.hudson.jna.NativeUtils;
//#endif
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
//#if V1 || V2 || V3 || V4
import org.apache.tools.ant.types.FileSet;
//#endif
import org.apache.tools.ant.taskdefs.Chmod;
import org.apache.tools.ant.taskdefs.Copy;
//#if V0
import org.apache.tools.ant.types.FileSet;
//#endif
//#if V1 || V2 || V3
import org.apache.commons.lang.time.FastDateFormat;
//#endif
//#if V4
import org.apache.commons.lang3.time.FastDateFormat;
//#endif
//#if V1 || V2 || V3 || V4
import org.apache.commons.io.IOUtils;
//#endif
//#if V0 || V1 || V2 || V3
import org.jruby.ext.posix.FileStat;
import org.jruby.ext.posix.POSIX;
//#endif
//#if V0
import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
//#endif
import org.kohsuke.stapler.Stapler;
//#if V1 || V2 || V3
import org.jvnet.animal_sniffer.IgnoreJRERequirement;
//#endif
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
//#if V0
import java.io.*;
//#endif
//#if V1 || V2 || V3 || V4
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
//#endif
//#if V1 || V2 || V4
import java.io.StringReader;
//#endif
//#if V1 || V2 || V3 || V4
import java.io.Writer;
import java.io.PrintStream;
import java.io.InputStreamReader;
import java.io.FileInputStream;
import java.io.UnsupportedEncodingException;
//#endif
import java.net.InetAddress;
//#if V1 || V2 || V3 || V4
import java.net.UnknownHostException;
//#endif
import java.net.URI;
import java.net.URISyntaxException;
//#if V0
import java.net.UnknownHostException;
//#endif
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
//#if V0
import java.nio.charset.Charset;
//#endif
import java.nio.charset.CharsetEncoder;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.NumberFormat;
import java.text.ParseException;
//#if V0
import java.util.*;
//#endif
//#if V1 || V2 || V3 || V4
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Map;
//#endif
//#if V1 || V2 || V4
import java.util.MissingResourceException;
import java.util.Properties;
//#endif
//#if V1 || V2 || V3 || V4
import java.util.ResourceBundle;
import java.util.SimpleTimeZone;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
//#endif
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
//#if V0
import static hudson.util.jna.GNUCLibrary.LIBC;
//#endif
//#if V1 || V2 || V3 || V4
import java.nio.charset.Charset;
//#endif
//#if V1 || V2 || V3
import com.sun.jna.Native;
import com.sun.jna.Memory;
import com.sun.jna.NativeLong;
//#endif
public class Util {
    private static final long ONE_SECOND_MS = 1000;
    private static final long ONE_MINUTE_MS = 60 * ONE_SECOND_MS;
    private static final long ONE_HOUR_MS = 60 * ONE_MINUTE_MS;
    private static final long ONE_DAY_MS = 24 * ONE_HOUR_MS;
    private static final long ONE_MONTH_MS = 30 * ONE_DAY_MS;
    private static final long ONE_YEAR_MS = 365 * ONE_DAY_MS;
    public static <T> List<T> filter( Iterable<?> base, Class<T> type ) {
        List<T> r = new ArrayList<T>();
        for (Object i : base) {
//#if V0 || V1 || V2 || V3
            if(type.isInstance(i))
//#endif
//#if V4
            if (type.isInstance(i)) {
//#endif
                r.add(type.cast(i));
        }
//#if V4
        }
//#endif
        return r;
    }
    public static <T> List<T> filter( List<?> base, Class<T> type ) {
        return filter((Iterable)base,type);
    }
//#if V0 || V1 || V2 || V3
    private static final Pattern VARIABLE = Pattern.compile("\\$([A-Za-z0-9_]+|\\{[A-Za-z0-9_]+\\}|\\$)");
//#endif
//#if V4
    private static final Pattern VARIABLE = Pattern.compile("\\$([A-Za-z0-9_]+|\\{[A-Za-z0-9_\\.+]+\\}|\\$)");
//#endif
    public static String replaceMacro(String s, Map<String,String> properties) {
        return replaceMacro(s,new VariableResolver.ByMap<String>(properties));
    }
    public static String replaceMacro(String s, VariableResolver<String> resolver) {
    	if (s == null) {
    		return null;
    	}
        int idx=0;
        while(true) {
            Matcher m = VARIABLE.matcher(s);
//#if V0 || V1 || V2 || V3
            if(!m.find(idx))   return s;
//#endif
//#if V4
            if (!m.find(idx)) {
                return s;
            }
//#endif
            String key = m.group().substring(1);
            String value;
            if(key.charAt(0)=='$') {
               value = "$";
            } else {
//#if V0 || V1 || V2 || V3
               if(key.charAt(0)=='{')  key = key.substring(1,key.length()-1);
//#endif
//#if V4
                if (key.charAt(0) == '{') {
                    key = key.substring(1, key.length() - 1);
                }
//#endif
               value = resolver.resolve(key);
            }
//#if V0 || V1 || V2 || V3
            if(value==null)
//#endif
//#if V4
            if (value == null) {
//#endif
                idx = m.end(); // skip this
//#if V0 || V1 || V2 || V3
            else {
//#endif
//#if V4
            } else {
//#endif
                s = s.substring(0,m.start())+value+s.substring(m.end());
                idx = m.start() + value.length();
            }
        }
    }
    public static String loadFile(File logfile) throws IOException {
        return loadFile(logfile, Charset.defaultCharset());
    }
    public static String loadFile(File logfile,Charset charset) throws IOException {
//#if V0 || V1 || V2 || V3
        if(!logfile.exists())
//#endif
//#if V4
        if (!logfile.exists()) {
//#endif
            return "";
//#if V4
        }
//#endif
        StringBuilder str = new StringBuilder((int)logfile.length());
        BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(logfile),charset));
//#if V0 || V1
        try {
//#endif
            char[] buf = new char[1024];
            int len;
//#if V0 || V1 || V2 || V3
            while((len=r.read(buf,0,buf.length))>0)
//#endif
//#if V4
        while ((len = r.read(buf, 0, buf.length)) > 0) {
//#endif
               str.append(buf,0,len);
//#if V0 || V1
        } finally {
            r.close();
//#endif
//#if V0 || V1 || V4
        }
//#endif
//#if V2 || V3 || V4
        r.close();
//#endif
        return str.toString();
    }
    public static void deleteContentsRecursive(File file) throws IOException {
        File[] files = file.listFiles();
//#if V0 || V1 || V2 || V3
        if(files==null)
//#endif
//#if V4
        if (files == null) {
//#endif
            return;     // the directory didn't exist in the first place
//#if V0 || V1 || V2 || V3
        for (File child : files)
//#endif
//#if V4
        }
        for (File child : files) {
//#endif
            deleteRecursive(child);
    }
//#if V4
    }
//#endif
    public static void deleteFile(File f) throws IOException {
        if (!f.delete()) {
            if(!f.exists())
//#if V4
            {
//#endif
                return;
//#if V4
            }
//#endif
            makeWritable(f);
            makeWritable(f.getParentFile());
            if(!f.delete() && f.exists()) {
                File[] files = f.listFiles();
//#if V0 || V1 || V2 || V3
                if(files!=null && files.length>0)
//#endif
//#if V4
                if (files != null && files.length > 0) {
//#endif
                    throw new IOException("Unable to delete " + f.getPath()+" - files in dir: "+Arrays.asList(files));
//#if V4
                }
//#endif
                throw new IOException("Unable to delete " + f.getPath());
            }
        }
    }
//#if V0 || V1 || V2 || V3
    @IgnoreJRERequirement
//#endif
    private static void makeWritable(File f) {
        try {
            Chmod chmod = new Chmod();
            chmod.setProject(new Project());
            chmod.setFile(f);
            chmod.setPerm("u+w");
            chmod.execute();
        } catch (BuildException e) {
            LOGGER.log(Level.INFO,"Failed to chmod "+f,e);
        }
        try {
            f.setWritable(true);
        } catch (NoSuchMethodError e) {
        }
//#if V4
        if (!Functions.isWindows()) {
//#endif
        try {// try libc chmod
//#if V0 || V1 || V2 || V3
            POSIX posix = PosixAPI.get();
            String path = f.getAbsolutePath();
            FileStat stat = posix.stat(path);
            posix.chmod(path, stat.mode()|0200); // u+w
        } catch (Throwable t) {
            LOGGER.log(Level.FINE,"Failed to chmod(2) "+f,t);
//#endif
//#if V3
        }
//#endif
//#if V4
                NativeUtils.getInstance().makeFileWritable(f);
            } catch (NativeAccessException exc) {
                LOGGER.log(Level.FINE, "Failed to chmod(2) " + f, exc);
//#endif
//#if V0 || V1 || V2 || V4
        }
    }
//#endif
//#if V3 || V4
    }
//#endif
    public static void deleteRecursive(File dir) throws IOException {
//#if V0 || V1 || V2 || V3
        if(!isSymlink(dir))
            deleteContentsRecursive(dir);
//#endif
//#if V0 || V1 || V2
        try {
            deleteFile(dir);
        } catch (IOException e) {
            if(!isSymlink(dir))
//#endif
//#if V4
        if (!isSymlink(dir)) {
//#endif
//#if V0 || V1 || V2 || V4
                deleteContentsRecursive(dir);
//#endif
//#if V0 || V1 || V2
            deleteFile(dir);
//#endif
//#if V0 || V1 || V2 || V4
        }
//#endif
//#if V3 || V4
        deleteFile(dir);
//#endif
//#if V0 || V1 || V2 || V4
    }
//#endif
//#if V3
    }
//#endif
    public static boolean isSymlink(File file) throws IOException {
        String name = file.getName();
//#if V0 || V1 || V2 || V3
        if (name.equals(".") || name.equals(".."))
//#endif
//#if V4
        if (name.equals(".") || name.equals("..")) {
//#endif
            return false;
//#if V4
        }
//#endif
        File fileInCanonicalParent;
        File parentDir = file.getParentFile();
        if ( parentDir == null ) {
            fileInCanonicalParent = file;
        } else {
            fileInCanonicalParent = new File( parentDir.getCanonicalPath(), name );
        }
        return !fileInCanonicalParent.getCanonicalFile().equals( fileInCanonicalParent.getAbsoluteFile() );
    }
    public static File createTempDir() throws IOException {
        File tmp = File.createTempFile("hudson", "tmp");
//#if V0 || V1 || V2 || V3
        if(!tmp.delete())
//#endif
//#if V4
        if (!tmp.delete()) {
//#endif
            throw new IOException("Failed to delete "+tmp);
//#if V0 || V1 || V2 || V3
        if(!tmp.mkdirs())
//#endif
//#if V4
        }
        if (!tmp.mkdirs()) {
//#endif
            throw new IOException("Failed to create a new directory "+tmp);
//#if V4
        }
//#endif
        return tmp;
    }
    private static final Pattern errorCodeParser = Pattern.compile(".*CreateProcess.*error=([0-9]+).*");
    public static void displayIOException( IOException e, TaskListener listener ) {
        String msg = getWin32ErrorMessage(e);
//#if V0 || V1 || V2 || V3
        if(msg!=null)
//#endif
//#if V4
        if (msg != null) {
//#endif
            listener.getLogger().println(msg);
    }
//#if V4
    }
//#endif
    public static String getWin32ErrorMessage(IOException e) {
        return getWin32ErrorMessage((Throwable)e);
    }
    public static String getWin32ErrorMessage(Throwable e) {
        String msg = e.getMessage();
        if(msg!=null) {
            Matcher m = errorCodeParser.matcher(msg);
            if(m.matches()) {
                try {
                    ResourceBundle rb = ResourceBundle.getBundle("/hudson/win32errors");
                    return rb.getString("error"+m.group(1));
                } catch (Exception _) {
                }
            }
        }
//#if V0 || V1 || V2 || V3
        if(e.getCause()!=null)
//#endif
//#if V4
        if (e.getCause() != null) {
//#endif
            return getWin32ErrorMessage(e.getCause());
//#if V4
        }
//#endif
        return null; // no message
    }
    public static String getWin32ErrorMessage(int n) {
//#if V0 || V1 || V2 || V4
        try {
//#endif
            ResourceBundle rb = ResourceBundle.getBundle("/hudson/win32errors");
            return rb.getString("error"+n);
//#if V0 || V1 || V2 || V4
        } catch (MissingResourceException e) {
            LOGGER.log(Level.WARNING,"Failed to find resource bundle",e);
            return null;
        }
    }
//#endif
//#if V3
    }
//#endif
    public static String getHostName() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            return "localhost";
        }
    }
    public static void copyStream(InputStream in,OutputStream out) throws IOException {
        byte[] buf = new byte[8192];
        int len;
//#if V0 || V1 || V2 || V3
        while((len=in.read(buf))>0)
//#endif
//#if V4
        while ((len = in.read(buf)) > 0) {
//#endif
            out.write(buf,0,len);
    }
//#if V4
    }
//#endif
    public static void copyStream(Reader in, Writer out) throws IOException {
        char[] buf = new char[8192];
        int len;
//#if V0 || V1 || V2 || V3
        while((len=in.read(buf))>0)
//#endif
//#if V4
        while ((len = in.read(buf)) > 0) {
//#endif
            out.write(buf,0,len);
    }
//#if V4
    }
//#endif
    public static void copyStreamAndClose(InputStream in,OutputStream out) throws IOException {
        try {
            copyStream(in,out);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
    public static void copyStreamAndClose(Reader in,Writer out) throws IOException {
        try {
            copyStream(in,out);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
    public static String[] tokenize(String s,String delimiter) {
        return QuotedStringTokenizer.tokenize(s,delimiter);
    }
    public static String[] tokenize(String s) {
        return tokenize(s," \t\n\r\f");
    }
    public static String[] mapToEnv(Map<String,String> m) {
        String[] r = new String[m.size()];
        int idx=0;
        for (final Map.Entry<String,String> e : m.entrySet()) {
            r[idx++] = e.getKey() + '=' + e.getValue();
        }
        return r;
    }
    public static int min(int x, int... values) {
        for (int i : values) {
//#if V0 || V1 || V2 || V3
            if(i<x)
//#endif
//#if V4
            if (i < x) {
//#endif
                x=i;
        }
//#if V4
        }
//#endif
        return x;
    }
    public static String nullify(String v) {
//#if V0
        return fixEmpty(v);
//#endif
//#if V1 || V2 || V3
        if(v!=null && v.length()==0)    v=null;
//#endif
//#if V4
        if (v != null && v.length() == 0) {
            v = null;
        }
//#endif
//#if V1 || V2 || V3 || V4
        return v;
//#endif
    }
    public static String removeTrailingSlash(String s) {
//#if V0 || V1 || V2 || V3
        if(s.endsWith("/")) return s.substring(0,s.length()-1);
        else                return s;
//#endif
//#if V4
        if (s.endsWith("/")) {
            return s.substring(0, s.length() - 1);
        } else {
            return s;
//#endif
    }
//#if V4
    }
//#endif
//#if V2 || V3 || V4
    private static final byte[] garbage = new byte[8192];
//#endif
    public static String getDigestOf(InputStream source) throws IOException {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
//#if V0 || V1
            byte[] buffer = new byte[1024];
//#endif
            DigestInputStream in =new DigestInputStream(source,md5);
            try {
//#if V0 || V1
                while(in.read(buffer)>0)
//#endif
//#if V2 || V3 || V4
                while(in.read(garbage)>0)
//#endif
                    ; // simply discard the input
            } finally {
                in.close();
            }
            return toHexString(md5.digest());
        } catch (NoSuchAlgorithmException e) {
            throw new IOException2("MD5 not installed",e);    // impossible
        }
    }
    public static String getDigestOf(String text) {
        try {
            return getDigestOf(new ByteArrayInputStream(text.getBytes("UTF-8")));
        } catch (IOException e) {
            throw new Error(e);
        }
    }
    public static SecretKey toAes128Key(String s) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.reset();
            digest.update(s.getBytes("UTF-8"));
            return new SecretKeySpec(digest.digest(),0,128/8, "AES");
        } catch (NoSuchAlgorithmException e) {
            throw new Error(e);
        } catch (UnsupportedEncodingException e) {
            throw new Error(e);
        }
    }
    public static String toHexString(byte[] data, int start, int len) {
        StringBuilder buf = new StringBuilder();
        for( int i=0; i<len; i++ ) {
            int b = data[start+i]&0xFF;
//#if V0 || V1 || V2 || V3
            if(b<16)    buf.append('0');
//#endif
//#if V4
            if (b < 16) {
                buf.append('0');
            }
//#endif
            buf.append(Integer.toHexString(b));
        }
        return buf.toString();
    }
    public static String toHexString(byte[] bytes) {
        return toHexString(bytes,0,bytes.length);
    }
    public static byte[] fromHexString(String data) {
        byte[] r = new byte[data.length() / 2];
//#if V0 || V1 || V2 || V3
        for (int i = 0; i < data.length(); i += 2)
//#endif
//#if V4
        for (int i = 0; i < data.length(); i += 2) {
//#endif
            r[i / 2] = (byte) Integer.parseInt(data.substring(i, i + 2), 16);
//#if V4
        }
//#endif
        return r;
    }
    public static String getTimeSpanString(long duration) {
        long years = duration / ONE_YEAR_MS;
        duration %= ONE_YEAR_MS;
        long months = duration / ONE_MONTH_MS;
        duration %= ONE_MONTH_MS;
        long days = duration / ONE_DAY_MS;
        duration %= ONE_DAY_MS;
        long hours = duration / ONE_HOUR_MS;
        duration %= ONE_HOUR_MS;
        long minutes = duration / ONE_MINUTE_MS;
        duration %= ONE_MINUTE_MS;
        long seconds = duration / ONE_SECOND_MS;
        duration %= ONE_SECOND_MS;
        long millisecs = duration;
//#if V0 || V1 || V2 || V3
        if (years > 0)
//#endif
//#if V4
        if (years > 0) {
//#endif
            return makeTimeSpanString(years, Messages.Util_year(years), months, Messages.Util_month(months));
//#if V0 || V1 || V2 || V3
        else if (months > 0)
//#endif
//#if V4
        } else if (months > 0) {
//#endif
            return makeTimeSpanString(months, Messages.Util_month(months), days, Messages.Util_day(days));
//#if V0 || V1 || V2 || V3
        else if (days > 0)
//#endif
//#if V4
        } else if (days > 0) {
//#endif
            return makeTimeSpanString(days, Messages.Util_day(days), hours, Messages.Util_hour(hours));
//#if V0 || V1 || V2 || V3
        else if (hours > 0)
//#endif
//#if V4
        } else if (hours > 0) {
//#endif
            return makeTimeSpanString(hours, Messages.Util_hour(hours), minutes, Messages.Util_minute(minutes));
//#if V0 || V1 || V2 || V3
        else if (minutes > 0)
//#endif
//#if V4
        } else if (minutes > 0) {
//#endif
            return makeTimeSpanString(minutes, Messages.Util_minute(minutes), seconds, Messages.Util_second(seconds));
//#if V0 || V1 || V2 || V3
        else if (seconds >= 10)
//#endif
//#if V4
        } else if (seconds >= 10) {
//#endif
            return Messages.Util_second(seconds);
//#if V0 || V1 || V2 || V3
        else if (seconds >= 1)
//#endif
//#if V4
        } else if (seconds >= 1) {
//#endif
            return Messages.Util_second(seconds+(float)(millisecs/100)/10); // render "1.2 sec"
//#if V0 || V1 || V2 || V3
        else if(millisecs>=100)
//#endif
//#if V4
        } else if (millisecs >= 100) {
//#endif
            return Messages.Util_second((float)(millisecs/10)/100); // render "0.12 sec".
//#if V0 || V1 || V2 || V3
        else
//#endif
//#if V4
        } else {
//#endif
            return Messages.Util_millisecond(millisecs);
    }
//#if V4
    }
//#endif
    private static String makeTimeSpanString(long bigUnit,
                                             String bigLabel,
                                             long smallUnit,
                                             String smallLabel) {
        String text = bigLabel;
//#if V0 || V1 || V2 || V3
        if (bigUnit < 10)
//#endif
//#if V4
        if (bigUnit < 10) {
//#endif
            text += ' ' + smallLabel;
//#if V4
        }
//#endif
        return text;
    }
    public static String getPastTimeString(long duration) {
        return Messages.Util_pastTime(getTimeSpanString(duration));
    }
    public static String combine(long n, String suffix) {
        String s = Long.toString(n)+' '+suffix;
        if(n!=1)
//#if V4
        {
//#endif
            s += "s";
//#if V4
        }
//#endif
        return s;
    }
    public static <T> List<T> createSubList( Collection<?> source, Class<T> type ) {
        List<T> r = new ArrayList<T>();
        for (Object item : source) {
//#if V0 || V1 || V2 || V3
            if(type.isInstance(item))
//#endif
//#if V4
            if (type.isInstance(item)) {
//#endif
                r.add(type.cast(item));
        }
//#if V4
        }
//#endif
        return r;
    }
    public static String encode(String s) {
        try {
            boolean escaped = false;
            StringBuilder out = new StringBuilder(s.length());
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            OutputStreamWriter w = new OutputStreamWriter(buf,"UTF-8");
            for (int i = 0; i < s.length(); i++) {
//#if V0 || V1
                int c = s.charAt(i);
//#endif
//#if V2 || V3 || V4
                int c = (int) s.charAt(i);
//#endif
                if (c<128 && c!=' ') {
                    out.append((char) c);
                } else {
                    w.write(c);
                    w.flush();
                    for (byte b : buf.toByteArray()) {
                        out.append('%');
                        out.append(toDigit((b >> 4) & 0xF));
                        out.append(toDigit(b & 0xF));
                    }
                    buf.reset();
                    escaped = true;
                }
            }
            return escaped ? out.toString() : s;
        } catch (IOException e) {
            throw new Error(e); // impossible
        }
    }
    private static final boolean[] uriMap = new boolean[123];
    static {
        String raw =
    "!  $ &'()*+,-. 0123456789   =  @ABCDEFGHIJKLMNOPQRSTUVWXYZ    _ abcdefghijklmnopqrstuvwxyz";
        int i;
//#if V0 || V1 || V2 || V3
        for (i = 0; i < 33; i++) uriMap[i] = true;
        for (int j = 0; j < raw.length(); i++, j++)
//#endif
//#if V4
        for (i = 0; i < 33; i++) {
            uriMap[i] = true;
        }
        for (int j = 0; j < raw.length(); i++, j++) {
//#endif
            uriMap[i] = (raw.charAt(j) == ' ');
    }
//#if V4
    }
//#endif
    public static String rawEncode(String s) {
        boolean escaped = false;
        StringBuilder out = null;
        CharsetEncoder enc = null;
        CharBuffer buf = null;
        char c;
        for (int i = 0, m = s.length(); i < m; i++) {
            c = s.charAt(i);
            if (c > 122 || uriMap[c]) {
                if (!escaped) {
                    out = new StringBuilder(i + (m - i) * 3);
                    out.append(s.substring(0, i));
                    enc = Charset.forName("UTF-8").newEncoder();
                    buf = CharBuffer.allocate(1);
                    escaped = true;
                }
                buf.put(0,c);
                buf.rewind();
                try {
                    ByteBuffer bytes = enc.encode(buf);
                    while (bytes.hasRemaining()) {
                        byte b = bytes.get();
                        out.append('%');
                        out.append(toDigit((b >> 4) & 0xF));
                        out.append(toDigit(b & 0xF));
                    }
//#if V0 || V1 || V2 || V3
                } catch (CharacterCodingException ex) { }
//#endif
//#if V4
                } catch (CharacterCodingException ex) {
                }
//#endif
            } else if (escaped) {
                out.append(c);
            }
        }
        return escaped ? out.toString() : s;
    }
    private static char toDigit(int n) {
        return (char)(n < 10 ? '0' + n : 'A' + n - 10);
    }
    public static String singleQuote(String s) {
        return '\''+s+'\'';
    }
    public static String escape(String text) {
//#if V0 || V1 || V2 || V3
        if (text==null)     return null;
//#endif
//#if V4
        if (text == null) {
            return null;
        }
//#endif
        StringBuilder buf = new StringBuilder(text.length()+64);
        for( int i=0; i<text.length(); i++ ) {
            char ch = text.charAt(i);
//#if V0 || V1 || V2 || V3
            if(ch=='\n')
//#endif
//#if V4
            if (ch == '\n') {
//#endif
                buf.append("<br>");
//#if V0 || V1 || V2 || V3
            else
            if(ch=='<')
//#endif
//#if V4
            } else if (ch == '<') {
//#endif
                buf.append("&lt;");
//#if V0 || V1 || V2 || V3
            else
            if(ch=='&')
//#endif
//#if V4
            } else if (ch == '&') {
//#endif
                buf.append("&amp;");
//#if V0 || V1 || V2 || V3
            else
//#endif
//#if V0 || V1 || V2
            if(ch=='"')
//#endif
//#if V4
            } else if (ch == '"') {
//#endif
//#if V0 || V1 || V2 || V4
                buf.append("&quot;");
//#endif
//#if V0 || V1 || V2
            else
            if(ch=='\'')
//#endif
//#if V4
            } else if (ch == '\'') {
//#endif
//#if V0 || V1 || V2 || V4
                buf.append("&#039;");
//#endif
//#if V0 || V1 || V2
            else
//#endif
//#if V0 || V1 || V2 || V3
            if(ch==' ') {
//#endif
//#if V4
            } else if (ch == ' ') {
//#endif
//#if V0 || V1 || V2 || V4
                // All spaces in a block of consecutive spaces are converted to
                // non-breaking space (&nbsp;) except for the last one.  This allows
                // significant whitespace to be retained without prohibiting wrapping.
//#endif
                char nextCh = i+1 < text.length() ? text.charAt(i+1) : 0;
                buf.append(nextCh==' ' ? "&nbsp;" : " ");
//#if V0 || V1 || V2 || V3
            }
            else
//#endif
//#if V4
            } else {
//#endif
                buf.append(ch);
        }
//#if V4
        }
//#endif
        return buf.toString();
    }
    public static String xmlEscape(String text) {
        StringBuilder buf = new StringBuilder(text.length()+64);
        for( int i=0; i<text.length(); i++ ) {
            char ch = text.charAt(i);
//#if V0 || V1 || V2 || V3
            if(ch=='<')
//#endif
//#if V4
            if (ch == '<') {
//#endif
                buf.append("&lt;");
//#if V0 || V1 || V2 || V3
            else
            if(ch=='&')
//#endif
//#if V4
            } else if (ch == '&') {
//#endif
                buf.append("&amp;");
//#if V0 || V1 || V2 || V3
            else
//#endif
//#if V4
            } else {
//#endif
//#if V1 || V2 || V4
                buf.append(ch);
        }
//#endif
//#if V4
        }
//#endif
//#if V1 || V2 || V4
        return buf.toString();
    }
    /**
//#endif
//#if V4
     * Methods acts as {@link #xmlEscape(String)} method with only difference that it also escapes
     * '\n', '\r' symbols
     *
     * @param text string to escape
     * @return escaped string.
     */
    public static String escapeString(String text) {
        StringBuilder buf = new StringBuilder(text.length() + 64);
        for (int i = 0; i < text.length(); i++) {
            char ch = text.charAt(i);// '\n', '\12', and '\x0A'
            switch (ch) {
                case '\n':
                    buf.append('\\').append('n');
                    break;
                case '\r':
                    buf.append('\\').append('r');
                    break;
                case '<':
                    buf.append("&lt;");
                    break;
                case '&':
                    buf.append("&amp;");
                    break;
                default:
//#endif
//#if V0 || V3 || V4
                buf.append(ch);
        }
//#endif
//#if V4
        }
//#endif
//#if V0 || V3 || V4
        return buf.toString();
    }
//#endif
//#if V0 || V4
    /**
//#endif
//#if V0 || V1 || V2 || V4
     * Creates an empty file.
     */
//#endif
    public static void touch(File file) throws IOException {
        new FileOutputStream(file).close();
    }
//#if V0 || V1 || V2 || V4
    /**
     * Copies a single file by using Ant.
     */
//#endif
    public static void copyFile(File src, File dst) throws BuildException {
        Copy cp = new Copy();
        cp.setProject(new org.apache.tools.ant.Project());
        cp.setTofile(dst);
        cp.setFile(src);
        cp.setOverwrite(true);
        cp.execute();
    }
//#if V0 || V1 || V2 || V4
    /**
     * Convert null to "".
     */
//#endif
    public static String fixNull(String s) {
//#if V0 || V1 || V2 || V3
        if(s==null)     return "";
        else            return s;
//#endif
//#if V4
        if (s == null) {
            return "";
        } else {
            return s;
//#endif
//#if V1 || V2 || V3 || V4
    }
//#endif
//#if V0 || V4
    }
//#endif
//#if V0 || V1 || V2 || V4
    /**
     * Convert empty string to null.
     */
//#endif
    public static String fixEmpty(String s) {
//#if V0 || V1 || V2 || V3
        if(s==null || s.length()==0)    return null;
//#endif
//#if V4
        if (s == null || s.length() == 0) {
            return null;
        }
//#endif
        return s;
    }
//#if V0 || V1 || V2 || V4
    /**
     * Convert empty string to null, and trim whitespace.
     *
     * @since 1.154
     */
//#endif
    public static String fixEmptyAndTrim(String s) {
//#if V0 || V1 || V2 || V3
        if(s==null)    return null;
//#endif
//#if V4
        if (s == null) {
            return null;
        }
//#endif
        return fixEmpty(s.trim());
    }
    public static <T> List<T> fixNull(List<T> l) {
        return l!=null ? l : Collections.<T>emptyList();
    }
    public static <T> Set<T> fixNull(Set<T> l) {
        return l!=null ? l : Collections.<T>emptySet();
    }
    public static <T> Collection<T> fixNull(Collection<T> l) {
        return l!=null ? l : Collections.<T>emptySet();
    }
//#if V0 || V1 || V2 || V4
    public static <T> Iterable<T> fixNull(Iterable<T> l) {
        return l!=null ? l : Collections.<T>emptySet();
    }
    /**
     * Cuts all the leading path portion and get just the file name.
     */
//#endif
    public static String getFileName(String filePath) {
        int idx = filePath.lastIndexOf('\\');
//#if V0 || V1 || V2 || V3
        if(idx>=0)
//#endif
//#if V4
        if (idx >= 0) {
//#endif
            return getFileName(filePath.substring(idx+1));
//#if V4
        }
//#endif
        idx = filePath.lastIndexOf('/');
//#if V0 || V1 || V2 || V3
        if(idx>=0)
//#endif
//#if V4
        if (idx >= 0) {
//#endif
            return getFileName(filePath.substring(idx+1));
//#if V4
        }
//#endif
        return filePath;
    }
//#if V0 || V1 || V2 || V4
    /**
     * Concatenate multiple strings by inserting a separator.
     */
//#endif
    public static String join(Collection<?> strings, String separator) {
        StringBuilder buf = new StringBuilder();
        boolean first=true;
        for (Object s : strings) {
//#if V0 || V1 || V2 || V3
            if(first)   first=false;
            else        buf.append(separator);
//#endif
//#if V4
            if (first) {
                first = false;
            } else {
                buf.append(separator);
            }
//#endif
            buf.append(s);
        }
        return buf.toString();
    }
//#if V0 || V1 || V2 || V4
    /**
     * Combines all the given collections into a single list.
     */
//#endif
    public static <T> List<T> join(Collection<? extends T>... items) {
        int size = 0;
//#if V0 || V1 || V2 || V3
        for (Collection<? extends T> item : items)
//#endif
//#if V4
        for (Collection<? extends T> item : items) {
//#endif
            size += item.size();
//#if V4
        }
//#endif
        List<T> r = new ArrayList<T>(size);
//#if V0 || V1 || V2 || V3
        for (Collection<? extends T> item : items)
//#endif
//#if V4
        for (Collection<? extends T> item : items) {
//#endif
            r.addAll(item);
//#if V4
        }
//#endif
        return r;
    }
//#if V0 || V1 || V2 || V4
    /**
     * Creates Ant {@link FileSet} with the base dir and include pattern.
     *
     * <p>
     * The difference with this and using {@link FileSet#setIncludes(String)}
     * is that this method doesn't treat whitespace as a pattern separator,
     * which makes it impossible to use space in the file path.
     *
     * @param includes
     *      String like "foo/bar/*.xml" Multiple patterns can be separated
//#endif
    public static FileSet createFileSet(File baseDir, String includes, String excludes) {
        FileSet fs = new FileSet();
        fs.setDir(baseDir);
        fs.setProject(new Project());
        StringTokenizer tokens;
        tokens = new StringTokenizer(includes,",");
        while(tokens.hasMoreTokens()) {
            String token = tokens.nextToken().trim();
            fs.createInclude().setName(token);
        }
        if(excludes!=null) {
            tokens = new StringTokenizer(excludes,",");
            while(tokens.hasMoreTokens()) {
                String token = tokens.nextToken().trim();
                fs.createExclude().setName(token);
            }
        }
        return fs;
    }
    public static FileSet createFileSet(File baseDir, String includes) {
        return createFileSet(baseDir,includes,null);
    }
    public static void createSymlink(File baseDir, String targetPath, String symlinkPath, TaskListener listener) throws InterruptedException {
//#if V0 || V1 || V2 || V3
        if(Functions.isWindows() || NO_SYMLINK)   return;
//#endif
//#if V4
        if (Functions.isWindows() || NO_SYMLINK) {
            return;
        }
//#endif
        try {
            String errmsg = "";
            File symlinkFile = new File(baseDir, symlinkPath);
            if (!symlinkFile.delete() && symlinkFile.exists())
//#if V4
            {
//#endif
                new LocalProc(new String[]{"rm","-rf", symlinkPath},new String[0],listener.getLogger(), baseDir).join();
//#if V0
            Integer r=null;
//#endif
//#if V1 || V2 || V3
            int r;
//#endif
//#if V0 || V1 || V2 || V3
            if (!SYMLINK_ESCAPEHATCH) {
                try {
                    r = LIBC.symlink(targetPath,symlinkFile.getAbsolutePath());
                    if (r!=0) {
                        r = Native.getLastError();
                        errmsg = LIBC.strerror(r);
//#endif
//#if V0
                    }
//#endif
//#if V1 || V2 || V3 || V4
                    }
//#endif
//#if V0 || V1 || V2 || V3
                } catch (LinkageError e) {
//#endif
//#if V0
                    if (PosixAPI.supportsNative()) {
//#endif
//#if V0 || V1 || V2 || V3
                        r = PosixAPI.get().symlink(targetPath,symlinkFile.getAbsolutePath());
//#endif
//#if V0
                    }
                }
            }
            if (r==null) {
//#endif
//#if V4
            boolean success = false;
            try {
                success = NativeUtils.getInstance().createSymlink(targetPath, baseDir);
            } catch (NativeAccessException ex) {
                errmsg = "Native function mod failed" + NativeUtils.getInstance().getLastUnixError();
//#endif
//#if V1 || V2 || V3 || V4
                }
//#endif
//#if V1 || V2 || V3
            } else // escape hatch, until we know that the above works well.
//#endif
//#if V0 || V1 || V2 || V3
                r = new LocalProc(new String[]{
//#endif
//#if V4
            if (!success) { // escape hatch, until we know that the above works well.
                success = new LocalProc(new String[]{
//#endif
                    "ln","-s", targetPath, symlinkPath},
//#if V0 || V1 || V2 || V3
                    new String[0],listener.getLogger(), baseDir).join();
//#endif
//#if V4
                        new String[0], listener.getLogger(), baseDir).join() == 0;
//#endif
//#if V0 || V4
            }
//#endif
//#if V0 || V1 || V2 || V3
            if (r!=0)
                listener.getLogger().println(String.format("ln -s %s %s failed: %d %s",targetPath, symlinkFile, r, errmsg));
//#endif
//#if V4
            if (!success) {
                listener.getLogger().println(String.format("ln -s %s %s failed: %s", targetPath, symlinkFile, errmsg));
            }
//#endif
        } catch (IOException e) {
            PrintStream log = listener.getLogger();
//#if V0 || V1 || V2
            log.printf("ln %s %s failed%n",targetPath, new File(baseDir, symlinkPath));
//#endif
//#if V3 || V4
            log.printf("ln %s %s failed\n",targetPath, new File(baseDir, symlinkPath));
//#endif
            Util.displayIOException(e,listener);
            e.printStackTrace( log );
        }
    }
//#if V0 || V1 || V2 || V3
    public static String resolveSymlink(File link, TaskListener listener) throws InterruptedException, IOException {
//#endif
//#if V0
        return resolveSymlink(link);
//#endif
//#if V4
    public static void chmod(File f, int mask, boolean tryNative) {
        if (Functions.isWindows()) {
            return; // noop
//#endif
//#if V0 || V4
    }
//#endif
//#if V0
    public static String resolveSymlink(File link) throws InterruptedException, IOException {
//#endif
//#if V0 || V1 || V2 || V3
        if(Functions.isWindows())     return null;
        String filename = link.getAbsolutePath();
//#endif
//#if V4
        if (tryNative) {
//#endif
        try {
//#if V0 || V1 || V2 || V3
            for (int sz=512; sz < 65536; sz*=2) {
                Memory m = new Memory(sz);
                int r = LIBC.readlink(filename,m,new NativeLong(sz));
                if (r<0) {
                    int err = Native.getLastError();
                    if (err==22/*EINVAL --- but is this really portable?*/)
                        return null; // this means it's not a symlink
                    throw new IOException("Failed to readlink "+link+" error="+ err+" "+ LIBC.strerror(err));
//#endif
//#if V4
                NativeUtils.getInstance().chmod(f, mask);
            } catch (NativeAccessException exc) {
                LOGGER.log(Level.WARNING, "Native function chmod failed ({0}). Using Ant''s chmod task instead.", NativeUtils.getInstance().getLastUnixError());
                _chmodAnt(f, mask);
//#endif
                }
//#if V0 || V1 || V2 || V3
                if (r==sz)
                    continue;   // buffer too small
                byte[] buf = new byte[r];
                m.read(0,buf,0,r);
                return new String(buf);
//#endif
//#if V4
        } else {
            _chmodAnt(f, mask);
//#endif
            }
//#if V0 || V1 || V2 || V3
            throw new IOException("Symlink too long: "+link);
        } catch (LinkageError e) {
            return PosixAPI.get().readlink(filename);
//#endif
        }
//#if V4
    public static void chmod(File f, int mask) {
        chmod(f, mask, true);
//#endif
//#if V3 || V4
    }
//#endif
//#if V4
    private static void _chmodAnt(File f, int mask) {
        Chmod chmodTask = new Chmod();
        chmodTask.setProject(new Project());
        chmodTask.setFile(f);
        chmodTask.setPerm(Integer.toOctalString(mask));
        chmodTask.execute();
    }
    public static String resolveSymlink(File link, TaskListener listener) {
        if (Functions.isWindows()) {
            return null;
//#endif
//#if V0 || V2 || V4
    }
//#endif
//#if V4
        try {
            return NativeUtils.getInstance().resolveSymlink(link);
        } catch (NativeAccessException exc) {
            listener.getLogger().print("Native function resolveSymlink failed " + NativeUtils.getInstance().getLastUnixError());
        }
        return null;
//#endif
//#if V1 || V4
    }
//#endif
    @Deprecated
    public static String encodeRFC2396(String url) {
        try {
            return new URI(null,url,null).toASCIIString();
        } catch (URISyntaxException e) {
            LOGGER.warning("Failed to encode "+url);    // could this ever happen?
            return url;
        }
    }
    public static String wrapToErrorSpan(String s) {
//#if V0 || V1 || V2 || V3
        s = "<span class=error><img src='"+
//#endif
//#if V0 || V1 || V2
            Stapler.getCurrentRequest().getContextPath()+ Jenkins.RESOURCE_PATH+
//#endif
//#if V3
            Stapler.getCurrentRequest().getContextPath()+ Hudson.RESOURCE_PATH+
//#endif
//#if V0 || V1 || V2 || V3
            "/images/none.gif' height=16 width=1>"+s+"</span>";
//#endif
//#if V4
        s = "<span class=error><img src='"
                + Stapler.getCurrentRequest().getContextPath() + Hudson.RESOURCE_PATH
                + "/images/none.gif' height=16 width=1>" + s + "</span>";
//#endif
        return s;
    }
    public static Number tryParseNumber(String numberStr, Number defaultNumber) {
        if ((numberStr == null) || (numberStr.length() == 0)) {
            return defaultNumber;
        }
        try {
            return NumberFormat.getNumberInstance().parse(numberStr);
        } catch (ParseException e) {
            return defaultNumber;
        }
    }
    public static boolean isOverridden(Class base, Class derived, String methodName, Class... types) {
        try {
            return !base.getMethod(methodName, types).equals(
                    derived.getMethod(methodName,types));
        } catch (NoSuchMethodException e) {
            throw new AssertionError(e);
        }
    }
    public static File changeExtension(File dst, String ext) {
        String p = dst.getPath();
        int pos = p.lastIndexOf('.');
//#if V0 || V1 || V2 || V3
        if (pos<0)  return new File(p+ext);
        else        return new File(p.substring(0,pos)+ext);
//#endif
//#if V3
    }
//#endif
//#if V4
        if (pos < 0) {
            return new File(p + ext);
        } else {
            return new File(p.substring(0, pos) + ext);
//#endif
//#if V0 || V1 || V4
    }
//#endif
//#if V2 || V4
    }
//#endif
//#if V0 || V1 || V2 || V4
    public static String intern(String s) {
        return s==null ? s : s.intern();
    }
//#endif
//#if V0 || V1 || V2
    @IgnoreJRERequirement
//#endif
//#if V0 || V1 || V2 || V4
    public static Properties loadProperties(String properties) throws IOException {
        Properties p = new Properties();
        try {
            p.load(new StringReader(properties));
        } catch (NoSuchMethodError e) {
            p.load(new ByteArrayInputStream(properties.getBytes()));
        }
        return p;
    }
//#endif
    public static final FastDateFormat XS_DATETIME_FORMATTER = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss'Z'",new SimpleTimeZone(0,"GMT"));
//#if V0 || V1 || V2 || V3
    public static final FastDateFormat RFC822_DATETIME_FORMATTER
            = FastDateFormat.getInstance("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US);
//#endif
//#if V4
    public static final FastDateFormat RFC822_DATETIME_FORMATTER = FastDateFormat.getInstance("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US);
//#endif
    private static final Logger LOGGER = Logger.getLogger(Util.class.getName());
    public static boolean NO_SYMLINK = Boolean.getBoolean(Util.class.getName()+".noSymLink");
    public static boolean SYMLINK_ESCAPEHATCH = Boolean.getBoolean(Util.class.getName()+".symlinkEscapeHatch");
}
//#endif
